package liquibase.change.core;

import java.util.ArrayList;
import java.util.List;

import liquibase.Liquibase;
import liquibase.change.ChangeMetaData;
import liquibase.change.ColumnConfig;
import liquibase.change.DatabaseChange;
import liquibase.change.DatabaseChangeProperty;
import liquibase.database.Database;
import liquibase.datatype.DataTypeFactory;
import liquibase.diff.output.EbaoDiffOutputControl;
import liquibase.exception.RollbackImpossibleException;
import liquibase.exception.ValidationErrors;
import liquibase.statement.SqlStatement;
import liquibase.statement.core.DeleteStatement;
import liquibase.statement.core.InsertOrUpdateStatement;
import liquibase.statement.prepared.InsertExecutablePreparedStatementChange;
import liquibase.statement.prepared.InsertUpdateExecutablePreparedStatement;

/**
 * Inserts data into an existing table.
 */
@DatabaseChange(name = "insertUpdate", description = "Insert/Update Row", priority = ChangeMetaData.PRIORITY_DEFAULT, appliesTo = "table")
public class InsertUpdateDataChange extends InsertDataChange implements InsertExecutablePreparedStatementChange {

  private String primaryKey;

  public void setPrimaryKey(String primaryKey) {
    this.primaryKey = primaryKey;
  }

  @Override
  @DatabaseChangeProperty(requiredForDatabase = "all")
  public String getPrimaryKey() {
    return primaryKey;
  }

  @Override
  public ValidationErrors validate(Database database) {
      ValidationErrors validate = super.validate(database);
      validate.checkRequiredField("primaryKey", primaryKey);
      return validate;
  }
  
  private SqlStatement[] sqlStatements;//cache
  
  @Override
  public SqlStatement[] generateStatements(Database database) {
    if (sqlStatements != null) {
      return sqlStatements;
    }

    if (Liquibase.isPreparedStatementPreferred()) {
      sqlStatements = new SqlStatement[] { new InsertUpdateExecutablePreparedStatement(
          database, this) };
      return sqlStatements;
    }

    InsertOrUpdateStatement statement = new InsertOrUpdateStatement(
        getCatalogName(), getSchemaName(), getTableName(), this.primaryKey);
    for (ColumnConfig column : getColumns()) {
      if (database.supportsAutoIncrement() && column.isAutoIncrement() != null
          && column.isAutoIncrement()) {
        // skip auto increment columns as they will be generated by the database
        continue;
      }

      statement.addColumnValue(column.getName(), column.getValueObject());
    }
    return new SqlStatement[] { statement };
  }

  @Override
  public SqlStatement[] generateRollbackStatements(Database database)
      throws RollbackImpossibleException {
    List<SqlStatement> statements = new ArrayList<SqlStatement>();
    SqlStatement[] forward = this.generateStatements(database);

    for (SqlStatement thisForward : forward) {
      InsertOrUpdateStatement thisInsert = (InsertOrUpdateStatement) thisForward;
      DeleteStatement delete = new DeleteStatement(getCatalogName(),
          getSchemaName(), getTableName());
      delete.setWhereClause(getWhereClause(thisInsert, database));
      statements.add(delete);
    }

    return statements.toArray(new SqlStatement[statements.size()]);
  }

  private String getWhereClause(
      InsertOrUpdateStatement insertOrUpdateStatement, Database database) {
    StringBuilder where = new StringBuilder();

    String[] pkColumns = insertOrUpdateStatement.getPrimaryKey().split(",");

    for (String thisPkColumn : pkColumns) {
      where.append(
          database.escapeColumnName(insertOrUpdateStatement.getCatalogName(),
              insertOrUpdateStatement.getSchemaName(),
              insertOrUpdateStatement.getTableName(), thisPkColumn)).append(
          " = ");
      Object newValue = insertOrUpdateStatement.getColumnValues().get(
          thisPkColumn);
      where.append(DataTypeFactory.getInstance().fromObject(newValue, database)
          .objectToSql(newValue, database));

      where.append(" AND ");
    }

    where.delete(where.lastIndexOf(" AND "), where.lastIndexOf(" AND ")
        + " AND ".length());
    return where.toString();
  }
}
